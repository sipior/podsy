#!env python
import os
import curses
import argparse
import configparser
import feedparser
import pickle

class windowpane:
    """A class of convenience for specifying window dimensions."""
    def __init__(self,height,width,yoffset,xoffset):
        self.height = height
        self.width = width
        self.y = yoffset
        self.x = xoffset

class cursor:
    """Just a dumb class to hold the co√∂rdinates of the cursor"""
    def __init__(self,x,y):
        self.x = x
        self.y = y

def set_colours():
    curses.init_pair(1, curses.COLOR_CYAN, -1)
    curses.init_pair(2, curses.COLOR_MAGENTA, -1)
    curses.init_pair(3, curses.COLOR_YELLOW, -1)
    curses.init_pair(4, curses.COLOR_WHITE, -1)
    curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_YELLOW)
    curses.init_pair(6, curses.COLOR_WHITE, curses.COLOR_MAGENTA)

def interface(scr, podcasts):
    scr.clear()
    scr.refresh()
    curses.start_color()
    curses.use_default_colors()
    set_colours()

    curs = cursor(1,1)
    select_podcast = 0
    select_episode = 0

    key_input = 0

# main interface loop
    while (key_input != ord('Q')):

        # Initialization
        scr.clear()
        curses.curs_set(0)
        height, width = scr.getmaxyx()
        player_height = 2
        height = height - player_height

        # podcast window dimensions
        pwin = windowpane(height, width // 3, 0, 0)
        # window to hold podcast list
        podlist = scr.subwin(pwin.height,pwin.width,pwin.y,pwin.x)
        
        # episode list window dimensions
        ewin = windowpane(height, width - pwin.width, 0, pwin.width)
        # list of episodes for each podcast
        epslist = scr.subwin(ewin.height,ewin.width,ewin.y,ewin.x)

        # write out list of podcasts
        podlist.attron(curses.color_pair(1))
        podlist.box(0,0)
        podlist.addstr(0,2," podcasts ")
        podlist.addstr(3,2,"{} {}".format(curs.x,curs.y))
        podlist.attroff(curses.color_pair(1))

        podlist.attron(curses.color_pair(4))
        podcast_list = sorted(podcasts.keys())
        for i in podcast_list[:pwin.height-2]:
            if podcast_list.index(i) == select_podcast :
                podlist.addnstr(podcast_list.index(i)+1,2,i,pwin.width,curses.color_pair(6))
            else:
                podlist.addnstr(podcast_list.index(i)+1,2,i,pwin.width)
        podlist.attroff(curses.color_pair(4))
            
        # write out episode list for selected podcast
        epslist.attron(curses.color_pair(2))
        epslist.box(0,0)
        epslist.addstr(0,2," episodes ")
        epslist.attroff(curses.color_pair(2))

        epslist.attron(curses.color_pair(4))
        episodes = podcasts['Reason Podcast'].entries
        for i in episodes[:ewin.height-2] :
            if episodes.index(i) == select_episode :
                epslist.addnstr(episodes.index(i)+1,2,i['title'],ewin.width-3,curses.color_pair(6))
            else:
                epslist.addnstr(episodes.index(i)+1,2,i['title'],ewin.width-3)
        epslist.attroff(curses.color_pair(4))

        if key_input in (curses.KEY_DOWN, ord('j')):
            curs.y = curs.y + 1
        elif key_input in (curses.KEY_UP, ord('k')):
            curs.y = curs.y - 1
        elif key_input in (curses.KEY_RIGHT, ord('l')):
            curs.x = ewin.x
            curs.y = 1
        elif key_input in (curses.KEY_LEFT, ord('h')):
            curs.x = pwin.x
            curs.y = 1

        # make sure cursor doesn't leave the window
        curs.x = max(1, curs.x)
        curs.x = min(curs.x, width - 1)
        curs.y = max(1, curs.y)
        curs.y = min(curs.y, height - 1)

        scr.move(curs.y,curs.x)
        scr.refresh()
        key_input = scr.getch()

def add_feed(url,podcasts):
    d = feedparser.parse(url)
    podcasts[d['feed']['title']] = d
    save_state(podcasts)
    
def save_state(podcasts):
    """ Initialise podcast data pickle if it doesn't exist, else stuff into jar """
    store = find_storage()
    gherkin = os.path.join(store,"podcasts.db")
    if not os.path.isfile(gherkin) :
        with open(gherkin,'wb') as f:
            pickle.dump(podcasts,f)
    else:
        with open(gherkin,'wb') as f:
            pickle.dump(podcasts,f)

def restore_state(podcasts):
    """ Initialise podcast data pickle if it doesn't exist, else remove from jar """
    store = find_storage()
    gherkin = os.path.join(store,"podcasts.db")
    if not os.path.isfile(gherkin) :
        with open(gherkin,'wb') as f:
            pickle.dump(podcasts,f)
    else:
        with open(gherkin,'rb') as f:
            podcasts = pickle.load(f)

def find_storage():
    """ Where should we store stuff (downloaded episodes, rss database, &cet.)? """
    store = os.path.expanduser('~/.local/share/potsy')
    if 'XDG_DATA_HOME' in os.environ :
        store = os.path.join(os.environ['XDG_DATA_HOME'],"potsy")
    if not os.path.isdir(store) :
        os.mkdir(store,0o700)
    return store

def main():
    env = {}
    podcasts = {}
    parser = argparse.ArgumentParser(description="A curses-based podcatcher")
    parser.add_argument("-c", "--config", help="use this config file instead")
    args = parser.parse_args()
    config = configparser.ConfigParser()

# Let's figure out where the hell our config file is hiding
    conffile = os.path.expanduser('~/.config/potsy/potsy.conf')
    if args.config is not None and os.path.isfile(args.config) :
        conffile = args.config
    elif 'XDG_CONFIG_HOME' in os.environ :
        p = os.path.join(os.environ['XDG_CONFIG_HOME'],"potsy/potsy.conf")
        if os.path.isfile(p) :
            conffile = p
    config.read(conffile)

    restore_state(podcasts)
    add_feed('https://feedpress.me/ReasonAudio', podcasts)
# Let's do this thing.
    curses.wrapper(interface, podcasts)

if __name__ == "__main__":
    main()
